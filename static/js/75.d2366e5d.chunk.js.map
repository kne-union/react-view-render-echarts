{"version":3,"sources":["../../node_modules/wordcloud/src/wordcloud2.js"],"names":["window","setImmediate","msSetImmediate","webkitSetImmediate","mozSetImmediate","oSetImmediate","postMessage","addEventListener","callbacks","undefined","message","evt","data","substr","length","stopImmediatePropagation","id","parseInt","clearImmediate","callback","push","toString","fn","setTimeout","msClearImmediate","webkitClearImmediate","mozClearImmediate","oClearImmediate","timer","clearTimeout","global","isSupported","canvas","document","createElement","getContext","ctx","getImageData","fillText","Array","prototype","some","minFontSize","hanWidth","mWidth","size","font","measureText","width","shuffleArray","arr","j","x","i","Math","floor","random","WordCloud","elements","options","timerId","Date","now","isArray","forEach","el","getElementById","Error","tagName","appendChild","settings","list","fontFamily","fontWeight","color","minSize","weightFactor","clearCanvas","backgroundColor","gridSize","drawOutOfBound","shrinkToFit","origin","drawMask","maskColor","maskGapWidth","wait","abortThreshold","abort","minRotation","PI","maxRotation","rotationSteps","shuffle","rotateRatio","shape","ellipticity","classes","hover","click","key","factor","pt","theta","sin","thetaPrime","cos","min","abs","sqrt","max","grid","ngx","ngy","center","maxRadius","escapeTime","getTextColor","getTextFontWeight","g","maskRectWidth","rotationRange","randomHslColor","getTextClasses","hovered","interactive","infoGrid","getInfoGridFromMouseTouchEvent","clientX","clientY","currentTarget","rect","getBoundingClientRect","touches","eventX","left","eventY","top","y","height","wordcloudhover","info","item","dimension","wordcloudclick","preventDefault","pointsAtRadius","getPointsAtRadius","radius","T","t","points","rx","exceedTime","getTime","fillGridAt","fillRect","putWord","word","weight","attributes","rotateDeg","extraDataArray","itemCopy","slice","splice","getItemExtraData","fontSize","mu","fcanvas","fctx","willReadFrequently","fw","fh","boxWidth","boxHeight","fgw","ceil","fgh","fillTextOffsetX","fillTextOffsetY","cgh","cgw","setAttribute","scale","translate","rotate","fillStyle","textBaseline","imageData","gy","occupied","gx","bounds","singleGridLoop","gw","gh","fillTextWidth","fillTextHeight","getTextInfo","r","tryToPutWordAtPoint","gxy","px","py","canFitText","distance","save","restore","span","transformRule","styleRules","position","display","lineHeight","whiteSpace","transform","webkitTransform","msTransform","transformOrigin","webkitTransformOrigin","msTransformOrigin","cssProp","textContent","style","attribute","className","drawText","w","h","updateGrid","concat","sendEvent","type","cancelable","details","event","CustomEvent","detail","dispatchEvent","this","loopingFunction","stoppingFunction","clearRect","bctx","bgPixel","webkitTapHighlightColor","stopInteraction","removeEventListener","listener","anotherWordCloudStart","loop","drawn","canceled","start","toFixed","stop"],"mappings":"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","file":"static/js/75.d2366e5d.chunk.js","sourcesContent":["/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.\n * Released under the MIT license\n */\n\n'use strict'\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate () {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout () {\n      if (!window.postMessage || !window.addEventListener) {\n        return null\n      }\n\n      var callbacks = [undefined]\n      var message = 'zero-timeout-message'\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout (callback) {\n        var id = callbacks.length\n        callbacks.push(callback)\n        window.postMessage(message + id.toString(36), '*')\n\n        return id\n      }\n\n      window.addEventListener('message', function setZeroTimeoutMessage (evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return\n        }\n\n        evt.stopImmediatePropagation()\n\n        var id = parseInt(evt.data.substr(message.length), 36)\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id]()\n        callbacks[id] = undefined\n      }, true)\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout (id) {\n        if (!callbacks[id]) {\n          return\n        }\n\n        callbacks[id] = undefined\n      }\n\n      return setZeroTimeout\n    })() ||\n    // fallback\n    function setImmediateFallback (fn) {\n      window.setTimeout(fn, 0)\n    }\n  })()\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate () {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback (timer) {\n      window.clearTimeout(timer)\n    }\n  })()\n}\n\n(function (global) {\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported () {\n    var canvas = document.createElement('canvas')\n    if (!canvas || !canvas.getContext) {\n      return false\n    }\n\n    var ctx = canvas.getContext('2d')\n    if (!ctx) {\n      return false\n    }\n    if (!ctx.getImageData) {\n      return false\n    }\n    if (!ctx.fillText) {\n      return false\n    }\n\n    if (!Array.prototype.some) {\n      return false\n    }\n    if (!Array.prototype.push) {\n      return false\n    }\n\n    return true\n  }())\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize () {\n    if (!isSupported) {\n      return\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d')\n\n    // start from 20\n    var size = 20\n\n    // two sizes to measure\n    var hanWidth, mWidth\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif'\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1)\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width\n      mWidth = ctx.measureText('m').width\n\n      size--\n    }\n\n    return 0\n  })()\n\n  var getItemExtraData = function (item) {\n    if (Array.isArray(item)) {\n      var itemCopy = item.slice()\n      // remove data we already have (word and weight)\n      itemCopy.splice(0, 2)\n      return itemCopy\n    } else {\n      return []\n    }\n  }\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray (arr) {\n    for (var j, x, i = arr.length; i;) {\n      j = Math.floor(Math.random() * i)\n      x = arr[--i]\n      arr[i] = arr[j]\n      arr[j] = x\n    }\n    return arr\n  }\n\n  var timer = {};\n  var WordCloud = function WordCloud (elements, options) {\n    if (!isSupported) {\n      return\n    }\n\n    var timerId = Math.floor(Math.random() * Date.now())\n\n    if (!Array.isArray(elements)) {\n      elements = [elements]\n    }\n\n    elements.forEach(function (el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el)\n        if (!elements[i]) {\n          throw new Error('The element id specified is not found.')\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw new Error('You must pass valid HTML elements, or ID of the element.')\n      }\n    })\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      shrinkToFit: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop () {},\n\n      minRotation: -Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationSteps: 0,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    }\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key]\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor\n      settings.weightFactor = function weightFactor (pt) {\n        return pt * factor // in px\n      }\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle'\n          break\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid (theta) {\n            return 1 - Math.sin(theta)\n          }\n          break\n\n          /*\n          To work out an X-gon, one has to calculate \"m\",\n          where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n          http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n          2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n          Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n          where t' equals to mod(t, 2PI/X)\n         */\n\n        case 'diamond':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4)\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime))\n          }\n          break\n\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n          // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n          settings.shape = function shapeSquare (theta) {\n            return Math.min(\n              1 / Math.abs(Math.cos(theta)),\n              1 / Math.abs(Math.sin(theta))\n            )\n          }\n          break\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle (theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3)\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'pentagon':\n          settings.shape = function shapePentagon (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5)\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime))\n          }\n          break\n\n        case 'star':\n          settings.shape = function shapeStar (theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10)\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime))\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime))\n            }\n          }\n          break\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4)\n\n    /* shorthand */\n    var g = settings.gridSize\n    var maskRectWidth = g - settings.maskGapWidth\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation)\n    var rotationSteps = Math.abs(Math.floor(settings.rotationSteps))\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation)\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime\n\n    /* function for getting the color of the text */\n    var getTextColor\n    function randomHslColor (min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)'\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor () {\n          return randomHslColor(10, 50)\n        }\n        break\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor () {\n          return randomHslColor(50, 90)\n        }\n        break\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color\n        }\n        break\n    }\n\n    /* function for getting the font-weight of the text */\n    var getTextFontWeight\n    if (typeof settings.fontWeight === 'function') {\n      getTextFontWeight = settings.fontWeight\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes\n    }\n\n    /* Interactive */\n    var interactive = false\n    var infoGrid = []\n    var hovered\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent (evt) {\n      var canvas = evt.currentTarget\n      var rect = canvas.getBoundingClientRect()\n      var clientX\n      var clientY\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX\n        clientY = evt.touches[0].clientY\n      } else {\n        clientX = evt.clientX\n        clientY = evt.clientY\n      }\n      var eventX = clientX - rect.left\n      var eventY = clientY - rect.top\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g)\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g)\n\n      return infoGrid[x][y]\n    }\n\n    var wordcloudhover = function wordcloudhover (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n\n      if (hovered === info) {\n        return\n      }\n\n      hovered = info\n      if (!info) {\n        settings.hover(undefined, undefined, evt)\n\n        return\n      }\n\n      settings.hover(info.item, info.dimension, evt)\n    }\n\n    var wordcloudclick = function wordcloudclick (evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt)\n      if (!info) {\n        return\n      }\n\n      settings.click(info.item, info.dimension, evt)\n      evt.preventDefault()\n    }\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = []\n    var getPointsAtRadius = function getPointsAtRadius (radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius]\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8\n\n      // Getting all the points at this radius\n      var t = T\n      var points = []\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0])\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI) // 0 to 1\n        }\n\n        // Push [x, y, t] t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI])\n      }\n\n      pointsAtRadius[radius] = points\n      return points\n    }\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime () {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold))\n    }\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg () {\n      if (settings.rotateRatio === 0) {\n        return 0\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0\n      }\n\n      if (rotationRange === 0) {\n        return minRotation\n      }\n\n      if (rotationSteps > 0) {\n        // Min rotation + zero or more steps * span of one step\n        return minRotation +\n          Math.floor(Math.random() * rotationSteps) *\n          rotationRange / (rotationSteps - 1)\n      } else {\n        return minRotation + Math.random() * rotationRange\n      }\n    }\n\n    var getTextInfo = function getTextInfo (word, weight, rotateDeg, extraDataArray) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false\n      var fontSize = settings.weightFactor(weight)\n      if (fontSize <= settings.minSize) {\n        return false\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor () {\n          var mu = 2\n          while (mu * fontSize < minFontSize) {\n            mu += 2\n          }\n          return mu\n        })()\n      }\n\n      // Get fontWeight that will be used to set fctx.font\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var fcanvas = document.createElement('canvas')\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true })\n\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu\n      var fh = Math.max(fontSize * mu,\n        fctx.measureText('m').width,\n        fctx.measureText('\\uFF37').width\n      ) / mu\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2\n      var boxHeight = fh * 3\n      var fgw = Math.ceil(boxWidth / g)\n      var fgh = Math.ceil(boxHeight / g)\n      boxWidth = fgw * g\n      boxHeight = fgh * g\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = -fw / 2\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = -fh * 0.4\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g)\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g)\n      var width = cgw * g\n      var height = cgh * g\n\n      fcanvas.setAttribute('width', width)\n      fcanvas.setAttribute('height', height)\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas)\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save()\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu)\n      fctx.translate(width * mu / 2, height * mu / 2)\n      fctx.rotate(-rotateDeg)\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000'\n      fctx.textBaseline = 'middle'\n      fctx.fillText(\n        word, fillTextOffsetX * mu,\n        (fillTextOffsetY + fontSize * 0.5) * mu\n      )\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data\n\n      if (exceedTime()) {\n        return false\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(\n          fillTextOffsetX * mu,\n          fillTextOffsetY, fw * mu, fh * mu\n        )\n        fctx.restore()\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = []\n      var gx = cgw\n      var gy, x, y\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2]\n      while (gx--) {\n        gy = cgh\n        while (gy--) {\n          y = g\n          /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n          singleGridLoop: while (y--) {\n            x = g\n            while (x--) {\n              if (imageData[((gy * g + y) * width +\n                (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy])\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx\n                }\n                if (gx > bounds[1]) {\n                  bounds[1] = gx\n                }\n                if (gy < bounds[0]) {\n                  bounds[0] = gy\n                }\n                if (gy > bounds[2]) {\n                  bounds[2] = gy\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)'\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n                }\n                break singleGridLoop\n              }\n            }\n          }\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)'\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5)\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)'\n        fctx.fillRect(\n          bounds[3] * g,\n          bounds[0] * g,\n          (bounds[1] - bounds[3] + 1) * g,\n          (bounds[2] - bounds[0] + 1) * g\n        )\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      }\n    }\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText (gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false\n          }\n          continue\n        }\n\n        if (!grid[px][py]) {\n          return false\n        }\n      }\n      return true\n    }\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText (gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, extraDataArray) {\n      var fontSize = info.fontSize\n      var color\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta, extraDataArray)\n      } else {\n        color = settings.color\n      }\n\n      // get fontWeight that will be used to set ctx.font and font style rule\n      var fontWeight\n      if (getTextFontWeight) {\n        fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray)\n      } else {\n        fontWeight = settings.fontWeight\n      }\n\n      var classes\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, extraDataArray)\n      } else {\n        classes = settings.classes\n      }\n\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d')\n          var mu = info.mu\n\n          // Save the current state before messing it\n          ctx.save()\n          ctx.scale(1 / mu, 1 / mu)\n\n          ctx.font = fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily\n          ctx.fillStyle = color\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate(\n            (gx + info.gw / 2) * g * mu,\n            (gy + info.gh / 2) * g * mu\n          )\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(-rotateDeg)\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle'\n          ctx.fillText(\n            word, info.fillTextOffsetX * mu,\n            (info.fillTextOffsetY + fontSize * 0.5) * mu\n          )\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight) */\n\n          // Restore the state.\n          ctx.restore()\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span')\n          var transformRule = ''\n          transformRule = 'rotate(' + (-rotateDeg / Math.PI * 180) + 'deg) '\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')'\n          }\n          var styleRules = {\n            position: 'absolute',\n            display: 'block',\n            font: fontWeight + ' ' +\n              (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            left: ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            top: ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            width: info.fillTextWidth + 'px',\n            height: info.fillTextHeight + 'px',\n            lineHeight: fontSize + 'px',\n            whiteSpace: 'nowrap',\n            transform: transformRule,\n            webkitTransform: transformRule,\n            msTransform: transformRule,\n            transformOrigin: '50% 40%',\n            webkitTransformOrigin: '50% 40%',\n            msTransformOrigin: '50% 40%'\n          }\n          if (color) {\n            styleRules.color = color\n          }\n          span.textContent = word\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp]\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute])\n            }\n          }\n          if (classes) {\n            span.className += classes\n          }\n          el.appendChild(span)\n        }\n      })\n    }\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt (x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return\n      }\n\n      grid[x][y] = false\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d')\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth)\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension }\n      }\n    }\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid (gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied\n      var drawMask = settings.drawMask\n      var ctx\n      if (drawMask) {\n        ctx = elements[0].getContext('2d')\n        ctx.save()\n        ctx.fillStyle = settings.maskColor\n      }\n\n      var dimension\n      if (interactive) {\n        var bounds = info.bounds\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        }\n      }\n\n      var i = occupied.length\n      while (i--) {\n        var px = gx + occupied[i][0]\n        var py = gy + occupied[i][1]\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item)\n      }\n\n      if (drawMask) {\n        ctx.restore()\n      }\n    }\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord (item) {\n      var word, weight, attributes\n      if (Array.isArray(item)) {\n        word = item[0]\n        weight = item[1]\n      } else {\n        word = item.word\n        weight = item.weight\n        attributes = item.attributes\n      }\n      var rotateDeg = getRotateDeg()\n\n      var extraDataArray = getItemExtraData(item)\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg, extraDataArray)\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false\n      }\n\n      if (exceedTime()) {\n        return false\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound && !settings.shrinkToFit) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1\n\n      var tryToPutWordAtPoint = function (gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2)\n        var gy = Math.floor(gxy[1] - info.gh / 2)\n        var gw = info.gw\n        var gh = info.gh\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n          (maxRadius - r), gxy[2], rotateDeg, attributes, extraDataArray)\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item)\n\n        // Return true so some() will stop and also return true.\n        return true\n      }\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r)\n\n        if (settings.shuffle) {\n          points = [].concat(points)\n          shuffleArray(points)\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        // If all the points returns false, array.some() returns false.\n        var drawn = points.some(tryToPutWordAtPoint)\n\n        if (drawn) {\n          // leave putWord() and return true\n          return true\n        }\n      }\n      if (settings.shrinkToFit) {\n        if (Array.isArray(item)) {\n          item[1] = item[1] * 3 / 4\n        } else {\n          item.weight = item.weight * 3 / 4\n        }\n        return putWord(item)\n      }\n      // we tried all distances but text won't fit, return false\n      return false\n    }\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent (type, cancelable, details) {\n      if (cancelable) {\n        return !elements.some(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          return !el.dispatchEvent(event)\n        }, this)\n      } else {\n        elements.forEach(function (el) {\n          var event = new CustomEvent(type, {\n            detail: details || {}\n          })\n          el.dispatchEvent(event)\n        }, this)\n      }\n    }\n\n    /* Start drawing on a canvas */\n    var start = function start () {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0]\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g)\n        ngy = Math.ceil(canvas.height / g)\n      } else {\n        var rect = canvas.getBoundingClientRect()\n        ngx = Math.ceil(rect.width / g)\n        ngy = Math.ceil(rect.height / g)\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin)\n        ? [settings.origin[0] / g, settings.origin[1] / g]\n        : [ngx / 2, ngy / 2]\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy))\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = []\n\n      var gx, gy, i\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function (el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d')\n            ctx.fillStyle = settings.backgroundColor\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1))\n          } else {\n            el.textContent = ''\n            el.style.backgroundColor = settings.backgroundColor\n            el.style.position = 'relative'\n          }\n        })\n\n        /* fill the grid with empty state */\n        gx = ngx\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            grid[gx][gy] = true\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d')\n\n        bctx.fillStyle = settings.backgroundColor\n        bctx.fillRect(0, 0, 1, 1)\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data\n\n        gx = ngx\n        var x, y\n        while (gx--) {\n          grid[gx] = []\n          gy = ngy\n          while (gy--) {\n            y = g\n            /* eslint no-labels: [\"error\", { \"allowLoop\": true }] */\n            singleGridLoop: while (y--) {\n              x = g\n              while (x--) {\n                i = 4\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false\n                    break singleGridLoop\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n        interactive = true\n\n        /* fill the grid with empty state */\n        gx = ngx + 1\n        while (gx--) {\n          infoGrid[gx] = []\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover)\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick)\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)'\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction () {\n          canvas.removeEventListener('wordcloudstart', stopInteraction)\n          canvas.removeEventListener('mousemove', wordcloudhover)\n          canvas.removeEventListener('click', wordcloudclick)\n          hovered = undefined\n        })\n      }\n\n      i = 0\n      var loopingFunction, stoppingFunction\n      if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout\n        stoppingFunction = window.clearTimeout\n      } else {\n        loopingFunction = window.setImmediate\n        stoppingFunction = window.clearImmediate\n      }\n\n      var addEventListener = function addEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.addEventListener(type, listener)\n        }, this)\n      }\n\n      var removeEventListener = function removeEventListener (type, listener) {\n        elements.forEach(function (el) {\n          el.removeEventListener(type, listener)\n        }, this)\n      }\n\n      var anotherWordCloudStart = function anotherWordCloudStart () {\n        removeEventListener('wordcloudstart', anotherWordCloudStart)\n        stoppingFunction(timer[timerId])\n      }\n\n      addEventListener('wordcloudstart', anotherWordCloudStart)\n      timer[timerId] = loopingFunction(function loop () {\n        if (i >= settings.list.length) {\n          stoppingFunction(timer[timerId])\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId];\n          return\n        }\n        escapeTime = (new Date()).getTime()\n        var drawn = putWord(settings.list[i])\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        })\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer[timerId])\n          settings.abort()\n          sendEvent('wordcloudabort', false)\n          sendEvent('wordcloudstop', false)\n          removeEventListener('wordcloudstart', anotherWordCloudStart)\n          delete timer[timerId]\n          return\n        }\n        i++\n        timer[timerId] = loopingFunction(loop, settings.wait)\n      }, settings.wait)\n    }\n\n    // All set, start the drawing\n    start()\n  }\n\n  WordCloud.isSupported = isSupported\n  WordCloud.minFontSize = minFontSize\n  WordCloud.stop = function stop () {\n    if (timer) {\n      for (var timerId in timer) {\n        window.clearImmediate(timer[timerId])\n      }\n    }\n  }\n\n  // Expose the library as an AMD module\n  if (typeof define === 'function' && define.amd) { // eslint-disable-line no-undef\n    global.WordCloud = WordCloud\n    define('wordcloud', [], function () { return WordCloud }) // eslint-disable-line no-undef\n  } else if (typeof module !== 'undefined' && module.exports) { // eslint-disable-line no-undef\n    module.exports = WordCloud // eslint-disable-line no-undef\n  } else {\n    global.WordCloud = WordCloud\n  }\n})(this) // jshint ignore:line\n"],"sourceRoot":""}